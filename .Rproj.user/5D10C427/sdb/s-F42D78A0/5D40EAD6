{
    "collab_server" : "",
    "contents" : "\n\n#' @import tibble\n#' @import knitr\n#' @import rmarkdown\nNULL\n\n\n\n\n#' Create a huxtable\n#'\n#' @param ... Named list of values, as passed to \\code{\\link{data_frame}}.\n#'\n#' @return An object of class 'huxtable'.\n#' @export\n#'\n#' @aliases hux\n#' @examples\n#' ht <- huxtable(column1 = 1:5, column2 = letters[1:5])\n#'\n#'\nhuxtable <- function (...) {\n  ht <- tibble::data_frame(...)\n  as_huxtable(ht)\n}\n\n#' @export\n#' @rdname huxtable\nhux <- huxtable\n\n#' Convert an object to a huxtable\n#'\n#' @param dfr\n#'\n#' @return\n#' @export\n#'\n#' @examples\nas_huxtable <- function(x, ...) UseMethod('as_huxtable')\n\n#' @export\nas_huxtable.default <- function (x, ...) {\n  for (att in huxtable_cell_attrs) {\n    attr(x, att) <- matrix(NA, nrow(x), ncol(x))\n  }\n  for (att in huxtable_col_attrs) {\n    attr(x, att) <- rep(NA, ncol(x))\n  }\n  for (att in huxtable_row_attrs) {\n    attr(x, att) <- rep(NA, nrow(x))\n  }\n  for (att in huxtable_table_attrs) {\n    attr(x, att) <- NA\n  }\n\n  for (att in names(huxtable_default_attrs)) {\n    attr(x, att)[] <- huxtable_default_attrs[[att]] # [[ indexing matters here\n  }\n\n  x <- tibble::as_tibble(x)\n  class(x) <- c('huxtable', class(x))\n  x\n}\n\n#' @export\nas_huxtable.table <- function(x, ...) {\n  as_huxtable(as.matrix(x, ...))\n}\n\n\n#' Subset a huxtable\n#'\n#' @param x A huxtable.\n#' @param i\n#' @param j\n#' @param drop Not used.\n#'\n#' @return A huxtable.\n#' @export\n#'\n#' @examples\n`[.huxtable` <- function (x, i, j, drop = FALSE) {\n  ss <- tibble::as_tibble(unclass(x))[i, j]\n  for (att in huxtable_cell_attrs) {\n    attr(ss, att) <- attr(x, att)[i, j, drop = drop]\n  }\n  for (att in huxtable_col_attrs) {\n    attr(ss, att) <- attr(x, att)[j]\n  }\n  for (att in huxtable_row_attrs) {\n    attr(ss, att) <- attr(x, att)[i]\n  }\n  for (att in huxtable_table_attrs) {\n    attr(ss, att) <- attr(x, att)\n  }\n\n  class(ss) <- class(x)\n  ss\n}\n\n#' @export\nknit_print.huxtable <- function (x, options, ...) {\n  of <- rmarkdown::default_output_format(knitr::current_input())\n  of <- of$name\n  # not sure if 'print' is the right default here...\n  call_name <- switch(of, pdf_document = 'to_latex', html_document = 'to_html', 'print')\n  res <- do.call(call_name, list(ht=x))\n  if (of == 'pdf_document') {\n    latex_deps <- list(\n            rmarkdown::latex_dependency('array'),\n            rmarkdown::latex_dependency('tabularx'),\n            rmarkdown::latex_dependency('siunitx'),\n            rmarkdown::latex_dependency('xcolor', options = 'table'),\n            rmarkdown::latex_dependency('multirow')\n          )\n    return(knitr::asis_output(res, meta = latex_deps))\n  } else {\n    return(knitr::asis_output(res))\n  }\n}\n\n# also print_html, print_latex?\n\nprint.huxtable <- function(ht, ...) {\n  cat(to_screen(ht, ...))\n}\n\nto_screen  <- function (ht, ...) UseMethod('to_screen')\nto_screen.huxtable <- function(ht, ...) {\n\n}\n\n\n\n\n#' @export\ntbl_sum.huxtable <- function (x) {\n  paste0('A huxtable: ', dim_desc(x))\n}\n\n\nas.tbl.huxtable <- function (x) {\n  cl <- class(x)\n  htcl <- which(cl == 'huxtable')\n  class(x) <- class(x)[-(1:htcl)]\n  x\n}\n\n#\n#\n# # interface\n#\n# library(tidyverse)\n# ht <- data_frame(a = letters[1:10], b = rnorm(10), c = sample(1:10), d = factor(rep(letters[1:2], 5)))\n# ht <- as_huxtable(ht)\n#\n# # one approach:\n# colspan(ht)[2,1] <- 2\n# colspan(ht)[2,1] # getter\n# valign(ht)[,'c'] <- 'top'\n# border(ht, 'bottom')[1:3,] <- 1\n# rowgroups(ht) <- list('Top' = 1:2, 'Bottom' = 3:10, 'Vowels' = c(1, 5, 9))\n# # we'd also like\n# colgroups(ht) <- list('Left' = c('a', 'b'))\n# # or even like `select`\n# colgroups(ht) <- list('Left' = a:b)\n#\n# # reminder; names(x)[2] <- 'two' works like\n# # `*tmp*` <- names(x)\n# # `*tmp*`[2] <- \"two\"\n# # names(x) <- `*tmp*`\n#\n# # a dplyr-like approach:\n# ht %>% border(rows(1:3), 1) %>% align(cols(c(2,4)), 'left')\n# # getters\n# ht %>% border(rows(1:3))\n# # area, with select-style names\n# ht %>% border(area(2:3, a:b))\n# # would be nice:\n# ht %>% border(even_rows(), 1)\n# # separate function to select contents?\n# ht %>% area(row_spec, col_spec) %>% set_xxx\n# # problem; how to 'unset' selected areas when an object is returned?\n# ht %>% area(1:2, 3:4) %>% do_stuff # should now return the whole ht object\n# ht %>% area(1:2, 3:4) %>% do_stuff %>% do_more_stuff # do_more_stuff only in the area()\n#\n# # it seems more natural to do\n# border(ht)[r, c] <- 'blah'\n\n# toy example. This works when you do e.g. reversed(tmp)[1, 1:2] <- c(20, 30)\n# reversed <- function(x) {\n#   dm <- dim(x)\n#   x[dm[1]:1 , dm[2]:1 ]\n# }\n#\n# `reversed<-` <- function(x, value) {\n#   dm <- dim(x)\n#   x[dm[1]:1 , dm[2]:1 ] <- value\n#   x\n# }\n#\n\n",
    "created" : 1486812443450.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1995664200",
    "id" : "5D40EAD6",
    "lastKnownWriteTime" : 1487876751,
    "last_content_update" : 1487876751511,
    "path" : "~/huxtable/R/huxtable.R",
    "project_path" : "R/huxtable.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}