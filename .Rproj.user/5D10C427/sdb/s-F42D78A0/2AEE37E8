{
    "collab_server" : "",
    "contents" : "\n\n#' Create LaTeX Representing a Huxtable\n#'\n#' @param ht A huxtable.\n#' @param ...\n#'\n#' @return \\code{to_latex} returns a string. \\code{print_latex} prints the string and returns \\code{NULL}.\n#' @export\n#'\n#' @examples\n#' ht <- huxtable(a = 1:3, b = letters[1:3])\n#' print_latex(ht)\nto_latex <- function (ht, ...) UseMethod('to_latex')\n\n#' @export\nto_latex.huxtable <- function (ht, ...){\n  # \\begin{tabular}{ l | c || r | }\n  # \\hline\n  # 1 & 2 & 3 \\\\\n  # 4 & 5 & 6 \\\\\n  # 7 & 8 & 9 \\\\\n  # \\hline\n  # \\end{tabular}\n  res <- '\\\\begin{tabularx}'\n  tw <- width(ht)\n  if (is.numeric(tw)) tw <- paste0(tw, '\\\\textwidth')\n  res <- paste0(res, '{', tw,'}')\n  col_widths <- col_widths(ht)\n  if (all(is.na(col_widths))) col_widths <- rep(1/ncol(ht), ncol(ht))\n  if (is.numeric(col_widths)) {\n    col_widths <- paste0(col_widths, '\\\\textwidth')\n  }\n  colspec <- '{'\n  for (mycol in 1:ncol(ht)) {\n    col_align <- align(ht)[,mycol]\n    if (length(unique(col_align)) > 1) warning('Cannot use multiple alignments in a single column in LaTeX, at column ',\n          mycol)\n    col_align <- col_align[1]\n\n    # colspec for tabularx is >{code}char{width}\n    # code is code to put first e.g. \\raggedright\n    # char can be p, m or b\n    # width is e.g. 0.3\\textwidth, but can also have various representations\n    # a good way to do % of table width is tabularx X type; then\n    # you can do\n    # >{\\hsize=1.2\\hsize}X; \\hsize is 1 for evenly sized columns\n    # but, can't do vertical align easily using tabularx. Can do it with 'renewcommand'.\n\n    colspec_align_str <- switch(as.character(col_align),\n          left    = '>{\\\\raggedright}',\n          right   = '>{\\\\raggedleft}',\n          decimal = '>',\n          centre  = ,\n          '>{\\\\centering}')\n\n    col_valign <- valign(ht)[,mycol]\n    if (length(unique(col_valign)) > 1) warning(\n          'Cannot use multiple vertical alignments in a single column in LaTeX, at column ', mycol)\n    col_valign <- col_valign[1]\n\n    colspec_valign_str <- switch(as.character(col_valign), middle = 'm', bottom = 'b', top = , 'p')\n    if (isTRUE(col_align == 'decimal')) colspec_valign_str <- 'S'\n    col_width <- col_widths[mycol]\n    colspec_valign_str <- paste0(colspec_valign_str, '{', col_width,  '}')\n    colspec <- paste0(colspec, colspec_align_str, colspec_valign_str, ' ')\n  }\n  colspec <- paste0(colspec, '}')\n  res <- paste0(res, colspec, '\\n')\n\n  cell_shadows_row <- cell_shadows(ht, 'row')\n  cell_shadows_col <- cell_shadows(ht, 'col')\n  for (myrow in 1:nrow(ht)) {\n    for (mycol in 1:ncol(ht)) {\n      if (cell_shadows_col[myrow, mycol]) next\n\n      contents <- ht[myrow, mycol]\n      if (! is.na(cell_color <- bgcolor(ht)[myrow, mycol])) {\n        # \\cellcolor[HTML]{AA0044}\n        cell_color <- as.vector(col2rgb(cell_color))\n        cell_color <- paste0(cell_color, collapse = ', ')\n        cell_color <- paste0(c('\\\\cellcolor[RGB]{', cell_color, '}'), collapse = '')\n        contents <- paste0(cell_color, ' ', contents)\n      }\n      if ((rs <- rowspan(ht)[myrow, mycol]) > 1) {\n        # the tcb switch may only work with v recent multirow\n        # ctb <- switch(valign(ht)[myrow, mycol],\n        #       top    = 't',\n        #       bottom = 'b',\n        #       middle = ,\n        #       'c')\n        # * is width, could be more specific\n        contents <- paste0('\\\\multirow{', rs,'}{*}{', contents,'}')\n      }\n      # must be this way round: multirow inside multicolumn\n      if ((cs <- colspan(ht)[myrow, mycol]) > 1) {\n        lcr <- switch(align(ht)[myrow, mycol],\n              left   = 'l',\n              right  = 'r',\n              center = ,\n              'c')\n        contents <- paste0('\\\\multicolumn{', cs,'}{', lcr ,'}{', contents,'}')\n      }\n      if (! cell_shadows_row[myrow, mycol]) res <- paste0(res, contents)\n      real_col <- sum(colspan(ht)[myrow, 1:mycol]) # but will this fail when we have multirows?\n      if (real_col < ncol(ht)) res <- paste0(res, ' & ')\n    }\n    res <- paste0(res, ' \\\\tabularnewline\\n')\n  }\n\n  res <- paste0(res, '\\\\end{tabularx}\\n')\n  res\n}\n\n\n#' @export\n#'\n#' @rdname to_latex\nprint_latex <- function (ht, ...) {\n  cat(to_latex(ht, ...))\n}\n",
    "created" : 1487876710260.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4090191280",
    "id" : "2AEE37E8",
    "lastKnownWriteTime" : 1487876714,
    "last_content_update" : 1487876714524,
    "path" : "~/huxtable/R/LaTeX.R",
    "project_path" : "R/LaTeX.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}