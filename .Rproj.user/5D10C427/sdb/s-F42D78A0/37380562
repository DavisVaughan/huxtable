{
    "collab_server" : "",
    "contents" : "\n\nhuxtable_cell_attrs <- c('align', 'valign', 'rowspan', 'colspan', 'bgcolor')\nhuxtable_col_attrs <- c('col_widths')\nhuxtable_row_attrs <- c()\nhuxtable_table_attrs <- c('width')\n# list preserves different arg types:\nhuxtable_default_attrs <- list(rowspan = 1, colspan = 1, align = 'center', valign = 'middle',\n    width = 1, col_widths = NA, bgcolor = NA)\n\n\nmake_getter_setters <- function(attr_name, attr_type = c('cell', 'row', 'col', 'table'), check_fun = NULL,\n  check_values = NULL, extra_code = NULL) {\n  attr_type <- match.arg(attr_type)\n  funs <- list()\n\n  funs[[attr_name]] <- eval(bquote(\n    function(ht) UseMethod(.(attr_name))\n  ))\n  funs[[paste0(attr_name, '.huxtable')]] <- eval(bquote(\n    function(ht) attr(ht, .(attr_name))\n  ))\n\n  setter <- paste0(attr_name, '<-')\n  funs[[setter]] <- eval(bquote(\n    function(ht) UseMethod(.(setter))\n  ))\n\n  check_fun <- if (! missing(check_fun)) bquote(stopifnot(.(check_fun)(value)))\n  check_dims <- switch(attr_type,\n    cell  = quote(stopifnot(ncol(value) == ncol(ht) && nrow(value) == nrow(ht))),\n    row   = quote(stopifnot(length(value) == nrow(ht))),\n    col   = quote(stopifnot(length(value) == ncol(ht))),\n    table = quote(stopifnot(length(value) == 1))\n  )\n  check_values <- if (! missing(check_values)) bquote(\n    stopifnot(all(na.omit(value) %in% .(check_values)))\n  )\n  extra_code <- if (! missing(extra_code)) substitute(extra_code)\n  funs[[paste0(setter, '.huxtable')]] <- eval(bquote(\n    function(ht, value) {\n      .(check_fun)\n      .(check_dims)\n      .(check_values)\n      .(extra_code)\n      attr(ht, attr_name)[] <- value\n    }\n  ))\n\n  lapply(names(funs), function (x) {\n    assign(x, funs[[x]], envir = parent.frame(3)) # 3: 1 for function(x), 2 for lapply, 3 for the caller!\n  })\n\n  NULL\n}\n\n#' Get or set vertical alignment.\n#'\n#' @param ht A huxtable.\n#' @param value Vertical alignment for specific cells.\n#'\n#' @return A matrix of alignment values. For `valign`, these may be 'top', 'middle',\n#' 'bottom' or \\code{NA}. For `align`, values may be 'left', 'center', 'middle' or \\code{NA}.\n#' @export\n#'\n#' @examples\n#' ht <- huxtable(a = 1:3, b = letters[1:3])\n#' valign(ht)[2,2] <- 'top'\n#' @name valign\nNULL\n\nmake_getter_setters('valign', 'cell', check_fun = is.character, check_values = c('top', 'middle', 'bottom'))\n\n\nvalign <- function (ht) UseMethod('valign')\n\n#' @export\nvalign.huxtable <- function (ht) attr(ht, 'valign')\n\n#' @export\n#' @rdname valign\n`valign<-` <- function (ht, value) UseMethod('valign<-')\n\n#' @export\n`valign<-.huxtable` <- function (ht, value = c('top', 'middle', 'bottom')) {\n  stopifnot(all(na.omit(value) %in% c('top', 'middle', 'bottom')))\n  attr(ht, 'valign')[] <- value\n  ht\n}\n\n#' @export\n#' @rdname valign\nalign <- function (ht) UseMethod('align')\n\n#' @export\nalign.huxtable <- function (ht) attr(ht, 'align')\n\n#' @export\n#' @rdname valign\n`align<-` <- function (ht, value) UseMethod('align<-')\n\n#' @export\n`align<-.huxtable` <- function (ht, value = c('left', 'center', 'right', 'decimal')) {\n  stopifnot(all(na.omit(value) %in% c('left', 'center', 'right', 'decimal')))\n  attr(ht, 'align')[] <- value\n  ht\n}\n\n#' Get or Set Table Width.\n#'\n#' @param ht A huxtable.\n#' @param value Table width, a length-1 vector.\n#'   If this is numeric it will be interpreted as a proportion of\n#'   the containing element. If it is character, it will be interpreted by CSS or LaTeX.\n#'\n#' @return A single value.\n#'\n#' @examples\n#' ht <- huxtable(a = 1:3, b = letters[1:3])\n#' width(ht) <- 0.8\n#' @export\nwidth <- function (ht) UseMethod('width')\n\n#' @export\nwidth.huxtable <- function (ht) attr(ht, 'width')\n\n#' @export\n#' @rdname width\n`width<-` <- function (ht, value) UseMethod('width<-')\n\n#' @export\n`width<-.huxtable` <- function (ht, value) {\n  stopifnot(length(value) == 1)\n  attr(ht, 'width') <- value\n  ht\n}\n\n\n#' Get or Set Column Widths.\n#'\n#' @param ht A huxtable.\n#' @param value Column widths, a vector.\n#'   If this is numeric it will be interpreted as a proportion of\n#'   the table width. If it is character, it will be interpreted by CSS or LaTeX.\n#'\n#' @return A vector of column widths.\n#'\n#' @examples\n#' ht <- huxtable(a = 1:3, b = letters[1:3])\n#' col_widths(ht) <- c(.3, .7)\n#' @export\ncol_widths <- function(ht) UseMethod('col_widths')\n\n#' @export\ncol_widths.huxtable <- function (ht) attr(ht, 'col_widths')\n\n#' @export\n#' @rdname col_widths\n`col_widths<-` <- function (ht, value) UseMethod('col_widths<-')\n\n#' @export\n`col_widths<-.huxtable` <- function (ht, value) {\n  stopifnot(length(value) == ncol(ht))\n  attr(ht, 'col_widths') <- value\n  ht\n}\n\n#' Get or Set Rowspan and Colspan.\n#'\n#' @param ht A huxtable.\n#' @param value How many rows or columns should the cell span.\n#'\n#' @return A numeric matrix of row or column spans. \\code{NA} means 1, the default.\n#' @export\n#'\n#' @examples\n#' ht <- huxtable(a = 1:3, b = letters[1:3])\n#' rowspan(ht)[1:2,1] <- 2\nrowspan <- function (ht) UseMethod('rowspan')\n\n#' @export\nrowspan.huxtable <- function (ht) attr(ht, 'rowspan')\n\n#' @export\n#' @rdname rowspan\n`rowspan<-` <- function (ht, value) UseMethod('rowspan<-')\n\n#' @export\n`rowspan<-.huxtable` <- function (ht, value) {\n  stopifnot(is.numeric(value))\n  if (any(na.omit( row(ht) + value - 1 > nrow(ht) ))) stop('rowspan would extend beyond bottom of table')\n  attr(ht, 'rowspan')[] <- value\n\n  # do we want to delete data that is shadowed by a row or colspan?\n  # advantage: represents 'truth', i.e. this output is invisible\n  # disadvantage: can't change rowspan repeatedly\n  # disadvantage: can't stop people putting data back in!\n  # maybe better not. Hard to manually maintain sanity. E.g. what if\n  # cell 2,1 has rowspan 2; then someone makes cell 1,1 have rowspan 2 also?\n\n  ht\n}\n\n#' @export\n#' @rdname rowspan\ncolspan <- function (ht) UseMethod('colspan')\n\n#' @export\ncolspan.huxtable <- function (ht) attr(ht, 'colspan')\n\n#' @export\n#' @rdname rowspan\n`colspan<-` <- function (ht, value) UseMethod('colspan<-')\n\n#' @export\n`colspan<-.huxtable` <- function (ht, value) {\n  stopifnot(is.numeric(value))\n  if (any(na.omit( col(ht) + value - 1 > ncol(ht) ))) stop('rowspan would extend beyond bottom of table')\n  attr(ht, 'colspan')[] <- value\n\n  ht\n}\n\n\n\n\n#' Get or Set Cell Background Color\n#'\n#' @param ht A huxtable.\n#' @param value Background color for the cell(s). NA is permissible\n#'\n#' @examples\n#' ht <- huxtable(a = 1:3, b = letters[1:3])\n#' bgcolor(ht)[1:2,1] <- 'orange'\n#' @export\nbgcolor <- function (ht) UseMethod('bgcolor')\n\n#' @export\nbgcolor.huxtable <- function (ht) attr(ht, 'bgcolor')\n\n#' @export\n#' @rdname valign\n`bgcolor<-` <- function (ht, value) UseMethod('bgcolor<-')\n\n#' @export\n`bgcolor<-.huxtable` <- function (ht, value) {\n  attr(ht, 'bgcolor')[] <- value\n  ht\n}\n\n\n\n\n# DELETE\n# foo <- function(attr_name, mat = TRUE, bonus_expr) {\n#   check_expr <- if (mat) quote(\n#     stopifnot(ncol(value) == ncol(ht) && nrow(value) == nrow(ht))\n#   ) else quote(\n#     stopifnot(length(value) == ncol(ht))\n#   )\n#   bonus_expr <- substitute(bonus_expr)\n#   eval(bquote(function(ht, value){\n#     .(check_expr)\n#     stopifnot(.(bonus_expr))\n#     attr(ht, attr_name)[] <- value\n#   }))\n# }\n\n# return matrix of whether cells are shadowed by rowspan from above or colspan from the left\ncell_shadows <- function(ht, row_or_col) {\n  row_or_col <- match.arg(row_or_col,  c('row', 'col'))\n  spanfun  <- if (row_or_col == 'row') rowspan else colspan\n  indexfun <- if (row_or_col == 'row') col else row\n\n  spans <- spanfun(ht)\n  # for each cell, what is the row/col number of its 'shadow'?\n  coverage <- spans - 1 + indexfun(spans)\n  # what is the farthest cell covered so far in each row/col?\n  cum_coverage <- if (row_or_col == 'col') apply(coverage, 2, cummax) else\n    t(apply(coverage, 1, cummax))\n  # for each cell, is it within a shadow of something earlier?\n  covered <- indexfun(spans) < cum_coverage\n  covered <- if (row_or_col == 'col') cbind(FALSE,covered[, 1:(ncol(covered) - 1)]) else\n    rbind(FALSE, covered[1:(nrow(covered) - 1), ])\n  covered\n}\n\n# is a given cell 'shadowed'?\ncell_shadowed <- function (ht, rn, cn, row_or_col = c('row', 'col')) {\n  row_or_col <- match.arg(row_or_col)\n  cell_shadows(ht, row_or_col)[rn, cn]\n}\n\n\n\n\n\n# attempt at alternative interface. We want some easy way to use\n# rows and cols in a dplyr::select style; or to do it by value?\n\n#' @export\n#' @rdname valign\nset_valign <- function (ht, rows, cols, value) {\n  valign(ht)[rows, cols] <- value\n  ht\n}\n\n\n",
    "created" : 1487605337814.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4051315931",
    "id" : "37380562",
    "lastKnownWriteTime" : 1487935533,
    "last_content_update" : 1487935533469,
    "path" : "~/huxtable/R/attributes.R",
    "project_path" : "R/attributes.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}